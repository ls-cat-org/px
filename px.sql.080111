--
-- PostgreSQL database dump
--

SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

--
-- Name: px; Type: SCHEMA; Schema: -; Owner: brister
--

CREATE SCHEMA px;


ALTER SCHEMA px OWNER TO brister;

SET search_path = px, pg_catalog;

--
-- Name: marheadertype; Type: TYPE; Schema: px; Owner: brister
--

CREATE TYPE marheadertype AS (
	sdist numeric,
	sexpt numeric,
	sstart numeric,
	saxis text,
	swidth numeric,
	dsdir text,
	sfn text,
	thelambda numeric
);


ALTER TYPE px.marheadertype OWNER TO brister;

--
-- Name: nextshottype; Type: TYPE; Schema: px; Owner: brister
--

CREATE TYPE nextshottype AS (
	dsdir text,
	dspid text,
	dsowidth numeric,
	dsoscaxis text,
	dsexp numeric,
	skey integer,
	sstart numeric,
	sfn text,
	dsphi numeric,
	dsomega numeric,
	dskappa numeric,
	dsdist numeric,
	dsnrg numeric
);


ALTER TYPE px.nextshottype OWNER TO brister;

--
-- Name: runqueuetype; Type: TYPE; Schema: px; Owner: brister
--

CREATE TYPE runqueuetype AS (
	dspid text,
	"type" text,
	k bigint,
	etc text
);


ALTER TYPE px.runqueuetype OWNER TO brister;

--
-- Name: _mar_insert_tf(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION _mar_insert_tf() RETURNS "trigger"
    AS $$
--
-- Consolidate _mar by converting inserts to update when possible
--
  DECLARE
    mrr text;		-- most recent raw response received
    mk  int;		-- serial number of most recent response
    mrs int;		-- old raw state
    nrs int;		-- new raw state
  BEGIN
    SELECT INTO mk, mrr, mrs mkey, mrawresponse, mrawstate FROM px._mar where mc=inet_client_addr() ORDER BY mkey DESC LIMIT 1;
    IF not found OR NEW.mrawresponse != mrr THEN
      nrs = NULL;
      IF position( 'is_state' in NEW.mrawresponse) = 1 THEN
        nrs = split_part( NEW.mrawresponse, ',', 2)::int;
      END IF;
      NEW.mrawstate = nrs;
      RETURN NEW;
    END IF;
    UPDATE px._mar SET mtu=now(), mcnt=mcnt+1 WHERE mkey=mk;
    RETURN NULL;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px._mar_insert_tf() OWNER TO lsadmin;

--
-- Name: _movedetectorin(bigint, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION _movedetectorin(pvmk bigint, value numeric) RETURNS void
    AS $$
-- _moveDetectorOut                                                                                                                                                                                    
-- "Action" function called when an epics variable (pvmk is the pvmonitors key) changes.  See actions in epics.sql                                                                                     
--                                                                                                                                                                                                     
  DECLARE
    moving boolean;     -- check to see if the motor is moving.  Do nothing if it is.                                                                                                                  
    stn    bigint;      -- pointer to station                                                                                                                                                          
  BEGIN
    SELECT INTO stn epvmlStn FROM px.epicsPVMLink LEFT JOIN epics._pvmonitors ON epvmlPV=pvmname WHERE pvmKey=pvmk limit 1;
    IF FOUND THEN
      SELECT INTO moving not (minpos=1) FROM epics.motions LEFT JOIN px.epicsLink on mmotorpvname=elPV WHERE elName='distance' and elStn=stn;
      IF NOT moving THEN
        PERFORM epics.moveit( elPV, dsIn) FROM px.distSaves,px.epicsLink WHERE elName='distance' and elStn=stn and dsStn=stn;
      END IF;
    END IF;
    return;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px._movedetectorin(pvmk bigint, value numeric) OWNER TO lsadmin;

--
-- Name: _movedetectorout(bigint, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION _movedetectorout(pvmk bigint, value numeric) RETURNS void
    AS $$
-- _moveDetectorOut                                                                                                                                                                                    
-- "Action" function called when an epics variable (pvmk is the pvmonitors key) changes.  See actions in epics.sql                                                                                     
--                                                                                                                                                                                                     
  DECLARE
    moving boolean;     -- check to see if the motor is moving.  Do nothing if it is.                                                                                                                  
    stn    bigint;      -- pointer to station                                                                                                                                                          
    dist   numeric;     -- saved detector position                                                                                                                                                     
  BEGIN
    SELECT INTO stn epvmlStn FROM px.epicsPVMLink LEFT JOIN epics._pvmonitors ON epvmlPV=pvmname WHERE pvmKey=pvmk limit 1;
    IF FOUND THEN
      SELECT INTO moving not (minpos=1) FROM epics.motions LEFT JOIN px.epicsLink on mmotorpvname=elPV WHERE elName='distance' and elStn=stn;
      IF NOT moving THEN
        SELECT INTO dist mrqspos FROM epics.motions LEFT JOIN  px.epicsLink ON elPV=mmotorpvname WHERE elStn=stn and elName='distance';
        UPDATE px.distSaves SET dsIn=dist, dsTs=now() WHERE dsStn=stn;
        PERFORM epics.moveit( elPV, dsOut) FROM px.distSaves,px.epicsLink WHERE elName='distance' and elStn=stn and dsStn=stn;
      END IF;
    END IF;
    return;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px._movedetectorout(pvmk bigint, value numeric) OWNER TO lsadmin;

--
-- Name: chkdir(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION chkdir(token text) RETURNS void
    AS $_$
  SELECT px.pushqueue( 'checkdir,'|| $1);
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.chkdir(token text) OWNER TO lsadmin;

--
-- Name: clearrunqueue(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION clearrunqueue() RETURNS void
    AS $$
  DELETE FROM px.runqueue WHERE rqStn = px.getstation();
$$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.clearrunqueue() OWNER TO lsadmin;

--
-- Name: copydataset(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION copydataset(token text) RETURNS text
    AS $$
  DECLARE
    rtn text;		-- new token
  BEGIN
    SELECT INTO rtn md5( nextval( 'px.datasets_dskey_seq')+random());
    EXECUTE 'CREATE TEMPORARY TABLE "' || rtn || '" AS SELECT * FROM px.datasets WHERE dspid=\'' || token || '\'';
    EXECUTE 'UPDATE "' || rtn || '" SET dspid=\'' || rtn || '\', dskey=nextval( \'px.datasets_dskey_seq\'), dsfp=px.next_prefix(dsfp), dsstn=px.getstation()';
    EXECUTE 'INSERT INTO px.datasets SELECT * FROM "' || rtn || '"';
    EXECUTE 'DROP TABLE "' || rtn || '"';
    PERFORM px.chkdir( rtn);
    PERFORM px.mkshots( rtn);

    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.copydataset(token text) OWNER TO lsadmin;

--
-- Name: copydataset(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION copydataset(token text, newprefix text) RETURNS text
    AS $$
  DECLARE
    pfx text;		-- prefix after being cleaned up
    rtn text;		-- new token
  BEGIN
    SELECT INTO rtn md5( nextval( 'px.datasets_dskey_seq')+random());
    pfx := px.fix_fn( newPrefix);
    EXECUTE 'CREATE TEMPORARY TABLE "' || rtn || '" AS SELECT * FROM px.datasets WHERE dspid=\'' || token || '\'';
    EXECUTE 'UPDATE "' || rtn || '" SET dspid=\'' || rtn || '\', dskey=nextval( \'px.datasets_dskey_seq\'), dsfp=\'' || pfx || '\', dsstn=px.getstation()';
    EXECUTE 'INSERT INTO px.datasets SELECT * FROM "' || rtn || '"';
    EXECUTE 'DROP TABLE "' || rtn || '"';
    PERFORM px.chkdir( rtn);
    PERFORM px.mkshots( rtn);

    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.copydataset(token text, newprefix text) OWNER TO lsadmin;

--
-- Name: delshots(text, text, integer, integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION delshots(pid text, "type" text, starti integer, endi integer) RETURNS void
    AS $$
  DECLARE
  BEGIN
    DELETE FROM px.shots WHERE sdspid=pid and stype=type and sindex >= starti and sindex <= endi;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.delshots(pid text, "type" text, starti integer, endi integer) OWNER TO lsadmin;

--
-- Name: ds_get_comment(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_comment(token text) RETURNS text
    AS $_$
  SELECT dscomment FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_comment(token text) OWNER TO lsadmin;

--
-- Name: ds_get_delta(text); Type: FUNCTION; Schema: px; Owner: brister
--

CREATE FUNCTION ds_get_delta(token text) RETURNS numeric
    AS $_$
  SELECT dsdelta FROM  px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_delta(token text) OWNER TO brister;

--
-- Name: ds_get_dir(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_dir(token text) RETURNS text
    AS $_$
  SELECT dsdir FROM  px.datasets where dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_dir(token text) OWNER TO lsadmin;

--
-- Name: ds_get_dist(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_dist(token text) RETURNS numeric
    AS $_$
  SELECT dsdist FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_dist(token text) OWNER TO lsadmin;

--
-- Name: ds_get_end(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_end(token text) RETURNS numeric
    AS $_$
  SELECT dsend FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_end(token text) OWNER TO lsadmin;

--
-- Name: ds_get_energy(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_energy(token text) RETURNS numeric
    AS $_$
  SELECT dsnrg FROM  px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_energy(token text) OWNER TO lsadmin;

--
-- Name: ds_get_esaf(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_esaf(token text) RETURNS bigint
    AS $_$
  SELECT dsesaf from px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_esaf(token text) OWNER TO lsadmin;

--
-- Name: ds_get_et(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_et(token text, "type" text) RETURNS interval
    AS $_$
--
-- returns time to complete dataset or snap
-- KLUDGE: note that the overhead (1.5 seconds) is hard coded here and this is clearly a bad idea
--
  SELECT (px.ds_get_nRemaining( $1, $2) * (px.ds_get_exp( $1) + 1.5)) * interval '1 second';
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_et(token text, "type" text) OWNER TO lsadmin;

--
-- Name: ds_get_exp(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_exp(token text) RETURNS numeric
    AS $_$
  SELECT dsexp FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_exp(token text) OWNER TO lsadmin;

--
-- Name: ds_get_expunit(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_expunit(token text) RETURNS text
    AS $_$
  SELECT dsexpunit FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_expunit(token text) OWNER TO lsadmin;

--
-- Name: ds_get_fp(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_fp(token text) RETURNS text
    AS $_$
  SELECT dsfp FROM px.datasets  where dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_fp(token text) OWNER TO lsadmin;

--
-- Name: ds_get_inst(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_inst(token text) RETURNS bigint
    AS $_$
  SELECT dsinst FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_inst(token text) OWNER TO lsadmin;

--
-- Name: ds_get_kappa(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_kappa(token text) RETURNS numeric
    AS $_$
  SELECT dskappa FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_kappa(token text) OWNER TO lsadmin;

--
-- Name: ds_get_nframes(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_nframes(token text) RETURNS integer
    AS $$
  DECLARE
    rtn int;	-- the return values
    ds record;	-- the current dataset record
  BEGIN
    rtn := 0;
    SELECT INTO ds * FROM px.datasets WHERE dspid=token;
    IF FOUND THEN
      IF coalesce( ds.dsdelta, 0) > 0 THEN
        rtn := ((ds.dsend - ds.dsstart)/ds.dsdelta)::int;
      END IF;
    END IF;
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_nframes(token text) OWNER TO lsadmin;

--
-- Name: ds_get_noscs(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_noscs(token text) RETURNS integer
    AS $_$
  SELECT dsnoscs FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_noscs(token text) OWNER TO lsadmin;

--
-- Name: ds_get_nremaining(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_nremaining(token text, thetype text) RETURNS integer
    AS $$
  DECLARE
    rtn int;	-- the count
  BEGIN
    SELECT INTO rtn count(*) FROM px.shots WHERE sdspid=token and stype=theType and sstate != 'Done';
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_nremaining(token text, thetype text) OWNER TO lsadmin;

--
-- Name: ds_get_nwedge(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_nwedge(token text) RETURNS integer
    AS $_$
  SELECT dsnwedge FROM  px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_nwedge(token text) OWNER TO lsadmin;

--
-- Name: ds_get_omega(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_omega(token text) RETURNS numeric
    AS $_$
  SELECT dsomega FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_omega(token text) OWNER TO lsadmin;

--
-- Name: ds_get_oscaxis(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_oscaxis(token text) RETURNS text
    AS $_$
  SELECT dsoscaxis FROM  px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_oscaxis(token text) OWNER TO lsadmin;

--
-- Name: ds_get_oscsense(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_oscsense(token text) RETURNS text
    AS $_$
  SELECT dsoscsense FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_oscsense(token text) OWNER TO lsadmin;

--
-- Name: ds_get_owidth(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_owidth(token text) RETURNS numeric
    AS $_$
  SELECT dsowidth FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_owidth(token text) OWNER TO lsadmin;

--
-- Name: ds_get_phi(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_phi(token text) RETURNS numeric
    AS $_$
  SELECT dsphi FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_phi(token text) OWNER TO lsadmin;

--
-- Name: ds_get_start(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_start(token text) RETURNS numeric
    AS $_$
  SELECT dsstart FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_start(token text) OWNER TO lsadmin;

--
-- Name: ds_get_state(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_state(token text) RETURNS text
    AS $_$
  SELECT dsstate FROM px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_state(token text) OWNER TO lsadmin;

--
-- Name: ds_get_wavelength(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_wavelength(token text) RETURNS numeric
    AS $_$
  SELECT 12.3984172/dsnrg FROM  px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_wavelength(token text) OWNER TO lsadmin;

--
-- Name: ds_get_who(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_get_who(token text) RETURNS bigint
    AS $_$
  SELECT dswho FROM  px.datasets WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_get_who(token text) OWNER TO lsadmin;

--
-- Name: ds_set_comment(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_comment(token text, arg2 text) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dscomment=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_comment(token text, arg2 text) OWNER TO lsadmin;

--
-- Name: ds_set_delta(text, numeric); Type: FUNCTION; Schema: px; Owner: brister
--

CREATE FUNCTION ds_set_delta(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets set dsdelta=arg2  where dspid=token;
    PERFORM px.mkshots( token);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_delta(token text, arg2 numeric) OWNER TO brister;

--
-- Name: ds_set_dir(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_dir(token text, arg2 text) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets set dsdir=px.fix_dir(arg2) where dspid=token;
    PERFORM px.chkdir( token);
    PERFORM px.mkshots( token);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_dir(token text, arg2 text) OWNER TO lsadmin;

--
-- Name: ds_set_dist(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_dist(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsdist=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_dist(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_end(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_end(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets set dsend=arg2 where dspid=token;
    PERFORM px.mkshots( token);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_end(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_energy(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_energy(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsnrg=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_energy(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_esaf(text, bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_esaf(token text, arg2 bigint) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsesaf=arg2 where dspid=token; end;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_esaf(token text, arg2 bigint) OWNER TO lsadmin;

--
-- Name: ds_set_exp(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_exp(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets set dsexp=arg2 where dspid=token;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_exp(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_expunit(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_expunit(token text, arg2 text) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsexpunit=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_expunit(token text, arg2 text) OWNER TO lsadmin;

--
-- Name: ds_set_fp(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_fp(token text, arg2 text) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets SET dsfp=px.fix_fn(arg2) WHERE dspid=token;
    PERFORM px.mkshots( token);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_fp(token text, arg2 text) OWNER TO lsadmin;

--
-- Name: ds_set_inst(text, bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_inst(token text, arg2 bigint) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsinst=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_inst(token text, arg2 bigint) OWNER TO lsadmin;

--
-- Name: ds_set_kappa(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_kappa(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dskappa=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_kappa(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_nframes(text, integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_nframes(token text, nframes integer) RETURNS void
    AS $$
  DECLARE
    ds record;	-- the dataset entry
    d  numeric;     -- our version of delta
    e  numeric;     -- new end
  BEGIN
    SELECT INTO ds * FROM px.datasets WHERE dspid=token;
    IF FOUND THEN
      d := abs(coalesce(ds.dsdelta, ds.dsowidth));
      IF d > 0 and ds.dsstart is not null THEN
        e := ds.dsstart + d * nframes;
        UPDATE px.datasets set dsend = e WHERE dskey=ds.dskey;
        PERFORM px.mkshots( token);
      END IF;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_nframes(token text, nframes integer) OWNER TO lsadmin;

--
-- Name: ds_set_noscs(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_noscs(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets set dsnoscs=arg2 where dspid=token;
    PERFORM px.mkshots( token);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_noscs(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_nwedge(text, integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_nwedge(token text, arg2 integer) RETURNS void
    AS $$
  BEGIN
    IF arg2 >= 0 THEN
      UPDATE px.datasets set dsnwedge=arg2 where dspid=token;
      PERFORM px.mkshots( token);
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_nwedge(token text, arg2 integer) OWNER TO lsadmin;

--
-- Name: ds_set_omega(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_omega(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsomega=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_omega(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_oscaxis(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_oscaxis(token text, arg2 text) RETURNS void
    AS $$
  BEGIN
    PERFORM akey FROM px.axes WHERE aaxis='arg2' and astn=px.getstation();
    IF FOUND THEN
      UPDATE px.datasets SET dsoscaxis=arg2 WHERE dspid=token;
      PERFORM px.mkshots( token);
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_oscaxis(token text, arg2 text) OWNER TO lsadmin;

--
-- Name: ds_set_oscsense(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_oscsense(token text, arg2 text) RETURNS void
    AS $$
  BEGIN
    PERFORM os FROM px.oscsenses WHERE os=arg2;
    IF FOUND THEN
      UPDATE px.datasets set dsoscsense=arg2 WHERE dspid=token;
      PERFORM px.mkshots( token);
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_oscsense(token text, arg2 text) OWNER TO lsadmin;

--
-- Name: ds_set_owidth(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_owidth(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets set dsowidth=arg2 where dspid=token;
    PERFORM px.mkshots( token);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_owidth(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_phi(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_phi(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsphi=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_phi(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_start(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_start(token text, arg2 numeric) RETURNS void
    AS $$
  BEGIN
    UPDATE px.datasets set dsstart=arg2 where dspid=token;
    PERFORM px.mkshots( token);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_start(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_state(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_state(token text, arg2 text) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dsstate=arg2 where dspid=token; end; $$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_state(token text, arg2 text) OWNER TO lsadmin;

--
-- Name: ds_set_wavelength(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_wavelength(token text, arg2 numeric) RETURNS void
    AS $_$
  UPDATE px.datasets SET dsnrg=12.3984172/$2  WHERE dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_wavelength(token text, arg2 numeric) OWNER TO lsadmin;

--
-- Name: ds_set_who(text, bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ds_set_who(token text, arg2 bigint) RETURNS void
    AS $$
  BEGIN UPDATE px.datasets set dswho=arg2 where dspid=token; end;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ds_set_who(token text, arg2 bigint) OWNER TO lsadmin;

--
-- Name: fix_dir(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION fix_dir(dir text) RETURNS text
    AS $_$
  SELECT regexp_replace( $1, '[^-._a-zA-Z0-9/]*', '','g');
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.fix_dir(dir text) OWNER TO lsadmin;

--
-- Name: fix_fn(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION fix_fn(fn text) RETURNS text
    AS $_$
  SELECT regexp_replace( $1, '[^-._a-zA-Z0-9]*', '','g');
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.fix_fn(fn text) OWNER TO lsadmin;

--
-- Name: flushqueue(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION flushqueue() RETURNS void
    AS $$
--
-- Function to flush the queue
--
  BEGIN
    DELETE FROM px._marqueue where mqc=inet_client_addr();
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.flushqueue() OWNER TO lsadmin;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: datasets; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE datasets (
    dskey integer NOT NULL,
    dspid text NOT NULL,
    dscreatets timestamp with time zone DEFAULT now(),
    dsstate text DEFAULT 'active'::text NOT NULL,
    dsesaf bigint,
    dswho bigint,
    dsinst bigint,
    dsdir text DEFAULT '/data'::text NOT NULL,
    dsdirs text DEFAULT 'New'::text NOT NULL,
    dsfp text DEFAULT 'default'::text,
    dsstn bigint,
    dsoscaxis text DEFAULT 'omega'::text,
    dsstart numeric DEFAULT 0,
    dsdelta numeric DEFAULT 1,
    dsowidth numeric DEFAULT 1,
    dsnoscs integer DEFAULT 1,
    dsoscsense text DEFAULT '+'::text,
    dsnwedge integer DEFAULT 0,
    dsend numeric DEFAULT 90,
    dsexp numeric DEFAULT 1,
    dsexpunit text DEFAULT 'Seconds'::text,
    dsphi numeric,
    dsomega numeric,
    dskappa numeric,
    dsdist numeric,
    dsnrg numeric,
    dscomment text
);


ALTER TABLE px.datasets OWNER TO lsadmin;

--
-- Name: getdataset(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getdataset(pid text) RETURNS SETOF datasets
    AS $_$
  SELECT * FROM px.datasets where dspid=$1;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getdataset(pid text) OWNER TO lsadmin;

--
-- Name: getdatasets(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getdatasets() RETURNS SETOF datasets
    AS $$
  SELECT * FROM px.datasets where dsstn=px.getstation() order by dsfp, dscreatets DESC;
$$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getdatasets() OWNER TO lsadmin;

--
-- Name: getrunqueuetype(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getrunqueuetype() RETURNS text
    AS $$
  SELECT coalesce(rqType,'') FROM px.runqueue WHERE rqStn=px.getstation() ORDER BY rqCTS ASC limit 1;
$$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getrunqueuetype() OWNER TO lsadmin;

--
-- Name: shots; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE shots (
    skey integer NOT NULL,
    sts timestamp with time zone DEFAULT now(),
    sdspid text,
    stype text NOT NULL,
    sindex integer NOT NULL,
    sfn text,
    sstart numeric,
    saxis text,
    swidth numeric,
    sexpt numeric,
    sexpu text,
    sphi numeric,
    somega numeric,
    skappa numeric,
    sdist numeric,
    snrg numeric,
    scmt text,
    sstate text
);


ALTER TABLE px.shots OWNER TO lsadmin;

--
-- Name: getshots(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getshots(pid text, "type" text) RETURNS SETOF shots
    AS $_$
  SELECT * FROM px.shots WHERE sdspid=$1 and stype=$2 ORDER BY sindex ASC;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getshots(pid text, "type" text) OWNER TO lsadmin;

--
-- Name: getshots(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getshots(pid text) RETURNS SETOF shots
    AS $_$
  SELECT * FROM px.shots WHERE sdspid=$1 ORDER BY stype, sindex ASC;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getshots(pid text) OWNER TO lsadmin;

--
-- Name: getstation(inet); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getstation(theip inet) RETURNS integer
    AS $_$
--
-- Returns the station key given an ip address
--
  SELECT  stnkey FROM px.stations left join px._config on stnname=cstation where $1=cdetector or $1=cdiffractometer;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getstation(theip inet) OWNER TO lsadmin;

--
-- Name: getstation(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getstation() RETURNS integer
    AS $$
--
-- Returns the station key for this connection
  SELECT px.getstation( inet_client_addr());
$$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getstation() OWNER TO lsadmin;

--
-- Name: getstation(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION getstation(thestn text) RETURNS integer
    AS $_$
--
-- Return the station key given the text (full or short) of the station name
  SELECT stnkey FROM px.stations where $1=stnname or $1=stnshortname;
$_$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.getstation(thestn text) OWNER TO lsadmin;

--
-- Name: inidetector(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION inidetector() RETURNS void
    AS $$
--
-- Initialize the detector
-- The intent is to create lock tables in this function if needed
-- TODO
  DECLARE
  BEGIN
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.inidetector() OWNER TO lsadmin;

--
-- Name: ininotifies(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ininotifies() RETURNS text
    AS $$
--                                                                                                                                                                                                                          
-- Used by the MD2 seqRun support code to setup notifies for the correct station                                                                                                                                            
-- We are making use in seqRun of the format 'station_notifytype' so the underscore is important                                                                                                                            
--                                                                                                                                                                                                                          
  DECLARE
    notifyrun   text;   -- notify name for run                                                                                                                                                                              
    notifysnap  text;   -- notify name for snap                                                                                                                                                                             
    notifykill  text;   -- notify name for kill                                                                                                                                                                             
    notifypause text;   -- notify name for pause                                                                                                                                                                            
    rtn         text;   -- prefix for all the notify names: SEE KLUDGE ABOVE                                                                                                                                                
  BEGIN
    rtn := NULL;
    SELECT INTO rtn, notifykill, notifysnap, notifyrun, notifypause split_part(cnotifykill,'_',1),cnotifykill, cnotifysnap, cnotifyrun, cnotifypause FROM px._config WHERE px.getstation( cstation)=px.getstation();
    IF FOUND THEN
      EXECUTE 'LISTEN ' || notifykill;
      EXECUTE 'LISTEN ' || notifysnap;
      EXECUTE 'LISTEN ' || notifyrun;
      EXECUTE 'LISTEN ' || notifypause;
    END IF;
    return rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.ininotifies() OWNER TO lsadmin;

--
-- Name: ispaused(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION ispaused() RETURNS boolean
    AS $$
  SELECT pps != 'Not Paused' FROM px.pause WHERE pStn = px.getstation();
$$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.ispaused() OWNER TO lsadmin;

--
-- Name: isthere(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION isthere(motion text, value numeric) RETURNS boolean
    AS $$
  DECLARE
    rtn boolean;
  BEGIN
    SELECT INTO rtn (minpos=1) and abs(mactpos-value)<=10^(-mprec) FROM epics.motions LEFT JOIN px.epicsLink on mmotorpvname=elPV WHERE elName=motion and elStn=px.getstation();
    return rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.isthere(motion text, value numeric) OWNER TO lsadmin;

--
-- Name: isthere(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION isthere(motion text) RETURNS boolean
    AS $$
  DECLARE
    rtn boolean;
  BEGIN
    SELECT INTO rtn (minpos=1) and not mweareincontrol FROM epics.motions LEFT JOIN px.epicsLink on mmotorpvname=elPV WHERE elName=motion and elStn=px.getstation();
    return rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.isthere(motion text) OWNER TO lsadmin;

--
-- Name: lock_detector(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION lock_detector() RETURNS void
    AS $$
--
-- Used by pxMarServer to let everyone know its idle and waiting for a command
--
  DECLARE
    cmd text;
  BEGIN
    SELECT INTO cmd 'LOCK TABLE ' || cdetectlocktable || ' IN ACCESS EXCLUSIVE MODE' FROM px._config WHERE cdetector=inet_client_addr() OR cdiffractometer=inet_client_addr() LIMIT 1;
    EXECUTE cmd;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.lock_detector() OWNER TO lsadmin;

--
-- Name: lock_detector_nowait(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION lock_detector_nowait() RETURNS void
    AS $$
--
-- Used by seqRun to test if the detecor is running
--
  DECLARE
    cmd text;
  BEGIN
    SELECT INTO cmd 'LOCK TABLE ' || cdetectlocktable || ' IN ACCESS EXCLUSIVE MODE NOWAIT' FROM px._config WHERE cdetector=inet_client_addr() OR cdiffractometer=inet_client_addr() LIMIT 1;
    EXECUTE cmd;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.lock_detector_nowait() OWNER TO lsadmin;

--
-- Name: lock_diffractometer(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION lock_diffractometer() RETURNS void
    AS $$
--
-- Used by seqRun to synchronize the detector: seqRun drops the lock when it's time to end the exposure
--
  DECLARE
    cmd text;
  BEGIN
    SELECT INTO cmd 'LOCK TABLE ' || cdifflocktable || ' IN ACCESS EXCLUSIVE MODE' FROM px._config WHERE cdetector=inet_client_addr() OR cdiffractometer=inet_client_addr() LIMIT 1;
    EXECUTE cmd;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.lock_diffractometer() OWNER TO lsadmin;

--
-- Name: lock_diffractometer_nowait(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION lock_diffractometer_nowait() RETURNS void
    AS $$
--
-- Used to test if the diffractometer is busy performing the exposure
--
  DECLARE
    cmd text;
  BEGIN
    SELECT INTO cmd 'LOCK TABLE ' || cdifflocktable || ' IN ACCESS EXCLUSIVE MODE NOWAIT' FROM px._config WHERE cdetector=inet_client_addr() OR cdiffractometer=inet_client_addr() LIMIT 1;
    EXECUTE cmd;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.lock_diffractometer_nowait() OWNER TO lsadmin;

--
-- Name: marheader(bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION marheader(k bigint) RETURNS marheadertype
    AS $$
  DECLARE
    rtn px.marheadertype;
  BEGIN
    SELECT INTO rtn coalesce(sdist,'150')::numeric    as sdist,
                    coalesce(sexpt,'1.0')::numeric    as sexpt,
                    coalesce(sstart, '0')::numeric  as sstart,
                    coalesce(saxis, 'omega') as saxis,
                    coalesce(swidth,'1.0')   as swidth,
                    coalesce(dsdir, '/data/public') as dsdir,
                    coalesce(sfn, 'default') as sfn,
                    px.rt_get_wavelength() as thelambda
                    from px.shots
                    left join px.datasets on sdspid=dspid
                    where skey=k;
    return rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.marheader(k bigint) OWNER TO lsadmin;

--
-- Name: marinit(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION marinit() RETURNS void
    AS $$
--                                                                                                                                                                                                   
-- access the _marinit table                                                                                                                                                                         
--                                                                                                                                                                                                   
  DECLARE
    r record;
    ntfy text;
  BEGIN
    SELECT INTO ntfy cnotifydetector FROM px._config LEFT JOIN px.stations ON cstation=stnname WHERE stnkey=px.getstation();
    EXECUTE 'LISTEN ' || ntfy;
    FOR r IN SELECT * FROM px._marinit order by miorder LOOP
      PERFORM px.pushqueue( r.miitem);
    END LOOP;
    EXECUTE 'NOTIFY ' || ntfy;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.marinit() OWNER TO lsadmin;

--
-- Name: marstatus(integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION marstatus(status integer) RETURNS text
    AS $$
-- returns the task as a string
--
  DECLARE
    s int;	-- low 4 bits of status
    rtn text;   -- the return value
  BEGIN
    s = (status::bit(32) & x'0000000f'::bit(32))::int;
    rtn = case s
      when 0 then 'idle'
      when 1 then 'acquire'
      when 2 then 'readout'
      when 3 then 'correct'
      when 4 then 'writing'
      when 5 then 'abortint'
      when 6 then 'unavailable'
      when 7 then 'error'
      when 8 then 'busy'
      else 'illegal state ' || s
      end;
    RETURN rtn;
   END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.marstatus(status integer) OWNER TO lsadmin;

--
-- Name: martaskstatus(integer, integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION martaskstatus(status integer, task integer) RETURNS text
    AS $$
--
-- returns the status of the given marccd task
  DECLARE
    s bit(4);	-- 4 bits of task status
    rtn text;   -- the return value
  BEGIN
    s = (((status::bit(32) >> (4*(task+1))) & x'0000000f'::bit(32))::int)::bit(4);
    rtn = case s
      when b'0110' then 'executing/error'
      when b'0100' then 'error'
      when b'0011' then 'executing/queued'
      when b'0010' then 'executing'
      when b'0001' then 'queued'
      when b'0000' then 'idle'
      else 'illegal status ' || s::int
      end;
    return rtn;
    END;
$$
    LANGUAGE plpgsql STRICT SECURITY DEFINER;


ALTER FUNCTION px.martaskstatus(status integer, task integer) OWNER TO lsadmin;

--
-- Name: mkindexsnap(text, numeric, numeric, integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION mkindexsnap(pid text, initialpos numeric, delta numeric, n integer) RETURNS void
    AS $$
  BEGIN
    
    FOR i IN 0..n-1 LOOP
      PERFORM px.mksnap( pid, initialpos + i::numeric * delta);
    END LOOP;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.mkindexsnap(pid text, initialpos numeric, delta numeric, n integer) OWNER TO lsadmin;

--
-- Name: mkorthoindexsnap(text, numeric, numeric, integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION mkorthoindexsnap(pid text, initialpos numeric, delta numeric, n integer) RETURNS void
    AS $$
  BEGIN
    
    FOR i IN 0..n-1 LOOP
      PERFORM px.mksnap( pid, initialpos + i::numeric * delta);
    END LOOP;

    FOR i IN 0..n-1 LOOP
      PERFORM px.mksnap( pid, initialpos + i::numeric * delta +90);
    END LOOP;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.mkorthoindexsnap(pid text, initialpos numeric, delta numeric, n integer) OWNER TO lsadmin;

--
-- Name: mkorthosnap(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION mkorthosnap(pid text, initialpos numeric) RETURNS void
    AS $$
  BEGIN
    PERFORM px.mksnap( pid, initialpos);
    PERFORM px.mksnap( pid, initialpos+90);
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.mkorthosnap(pid text, initialpos numeric) OWNER TO lsadmin;

--
-- Name: mkshots(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION mkshots(token text) RETURNS text
    AS $$
  DECLARE
    nframes int;		-- number of frames (1/2 # frames if wedges)
    newend  numeric;		-- caluculated end point
    sk      int;		-- the station key
    pid     text;		-- pid for shots/dataset
    fp      text;		-- the file prefix (already entered)
    fn      text;		-- the filename
    angle   numeric;		-- calculated diffraction angle
    delta   numeric;		-- difference between starting angles of adjacent frames
    n       int;		-- loop counter for wedge collection
    wnn     int;                -- loop counter for wedge name
    an      int;		-- counter for wedge collection used for angle calculation
    oldcnt  int;		-- count of old frames in this dataset
    ds      record;		-- dataset definition

  BEGIN
    SELECT INTO ds * from px.datasets where dspid=token;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'token % not found', token;
    END IF;

    --
    -- get file prefix
    --
    fp := ds.dsfp;

    --
    -- Delete untaken frames
    PERFORM 1 FROM px.nextshot() WHERE dspid=token;
    IF FOUND THEN
      DELETE FROM px.shots WHERE sstate = 'NotTaken' and sdspid=token;
    ELSE
      DELETE FROM px.shots WHERE sstate != 'Done' and sdspid=token;
    END IF;

    --
    -- calculate delta and number of frames
    --
    delta := ds.dsdelta;
    IF ds.dsend = ds.dsstart+ds.dsowidth THEN
      delta = ds.dsowidth;
      nframes = 1;
    ELSE
      IF delta=0 THEN
        delta := ds.dsowidth;
      END IF;
      IF delta = 0 THEN
        RAISE EXCEPTION 'delta not given and cannot be calculated';
      END IF;
      nframes := CAST((ds.dsend-ds.dsstart)/delta AS int);
    END IF;

    UPDATE px.datasets set dsend=ds.dsstart+delta*nframes WHERE dspid=token;
    SELECT INTO ds.dsend dsend FROM px.datasets WHERE dspid=token;

    IF ds.dsnwedge = 0 THEN
      FOR i IN 1..nframes LOOP
        PERFORM skey FROM px.shots WHERE sdspid=token and sindex=i and stype='normal';
        IF NOT FOUND THEN
          fn := fp || '.' || trim(to_char(i,'099'));
          angle := ds.dsstart + (i-1) * delta;
	  INSERT INTO px.shots ( sdspid, stype, sfn, sstart, sindex, sstate) VALUES (
            token,	-- sdspid
            'normal',	-- stype
            fn,		-- sfn
            angle,	-- sstart
            i,		-- sindex
            'NotTaken'	-- sstate
        );
        END IF;
      END LOOP;
    ELSE
      wnn := 0;
      n   := 0;
      an  := 0;
      WHILE n < 2*nframes LOOP
        FOR i IN 1..ds.dsnwedge LOOP
          PERFORM skey FROM px.shots WHERE sdspid=token and sindex=n+i and stype='normal';
          IF NOT FOUND THEN
            fn := fp || '_' || 'A' || '.' || trim( to_char( wnn+i, '099'));
            angle := ds.dsstart + (an+i-1) * delta;
            INSERT INTO px.shots ( sdspid, stype, sfn, sstart, sindex, sstate) VALUES (
              token,		-- sdspid
              'normal',		-- stype
              fn,		-- sfn
              angle,		-- sstart
              n+i,		-- sindex
              'NotTaken'	-- sstate
            );
          END IF;
	END LOOP;
        FOR i IN 1..ds.dsnwedge LOOP
          PERFORM skey FROM px.shots WHERE sdspid=token and sindex=n+ds.dsnwedge+i and stype='normal';
          IF NOT FOUND THEN
            fn := fp || '_' || 'B' || '.' || trim( to_char( wnn+i, '099'));
            angle := ds.dsstart + (an+i-1) * delta + 180;
            INSERT INTO px.shots ( sdspid, stype, sfn, sstart, sindex, sstate) VALUES (
              token,		-- sdspid
              'normal',		-- stype
              fn,		-- sfn
              angle,		-- sstart
              n+ds.dsnwedge+i,	-- sindex
              'NotTaken'	-- sstate
            );
          END IF;
	END LOOP;
        n   := n   + 2*ds.dsnwedge;
        an  := an  + ds.dsnwedge;
        wnn := wnn + ds.dsnwedge;
      END LOOP;
    END IF;
    RETURN token;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.mkshots(token text) OWNER TO lsadmin;

--
-- Name: mksnap(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION mksnap(pid text, initialpos numeric) RETURNS void
    AS $$
  DECLARE
    nexti int;  -- next value of the index                                                                                                                                                                                  
    fp text;    -- file prefix                                                                                                                                                                                              
  BEGIN
    SELECT INTO fp dsfp from px.datasets where dspid=pid;
    SELECT INTO nexti coalesce(max(sindex)+1,1) from px.shots where sdspid=pid and stype='snap';
    INSERT INTO px.shots (sdspid, stype, sindex, sfn, sstart, sstate) VALUES (
      pid, 'snap', nexti, fp || '_S.' || trim(to_char(nexti,'099')), initialpos, 'NotTaken'
    );
    PERFORM px.pushrunqueue( pid, 'snap');
--    PERFORM px.startrun();                                                                                                                                                                                                
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.mksnap(pid text, initialpos numeric) OWNER TO lsadmin;

--
-- Name: moveit(text, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION moveit(motion text, value numeric) RETURNS void
    AS $$
  DECLARE
  BEGIN
   PERFORM epics.moveit( elPV, value) FROM px.epicsLink WHERE elName=motion and elStn=px.getStation();
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.moveit(motion text, value numeric) OWNER TO lsadmin;

--
-- Name: newdataset(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION newdataset() RETURNS text
    AS $$
  DECLARE
    rtn text;		-- new token
  BEGIN
    SELECT INTO rtn md5( nextval( 'px.datasets_dskey_seq')+random());
    INSERT INTO px.datasets (dspid, dsstn) VALUES (rtn, px.getstation());
    PERFORM px.chkdir( rtn);
    PERFORM px.mkshots( rtn);
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.newdataset() OWNER TO lsadmin;

--
-- Name: newdataset(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION newdataset(token text) RETURNS text
    AS $$
  DECLARE
    rtn text;		-- new token
  BEGIN

    SELECT INTO rtn md5( nextval( 'px.datasets_dskey_seq')+random());

    EXECUTE 'CREATE TEMPORARY TABLE "' || rtn || '" AS SELECT * FROM px.datasets WHERE dspid=\'' || token || '\'';
    EXECUTE 'UPDATE "' || rtn || '" SET dspid=\'' || rtn || '\', dskey=nextval( \'px.datasets_dskey_seq\'), dsstn=px.getstation()';
    EXECUTE 'INSERT INTO px.datasets SELECT * FROM "' || rtn || '"';
    EXECUTE 'DROP TABLE "' || rtn || '"';
    PERFORM px.chkdir( rtn);
    PERFORM px.mkshots( rtn);


    -- From old dataset
    -- Delete all normal frames if none have been taken
    PERFORM skey FROM px.shots WHERE sdspid=token and sstate='Done' and stype='normal' limit 1;
    IF NOT FOUND THEN
      DELETE FROM px.shots WHERE sdspid=token and stype='normal';
    END IF;

    -- From old dataset
    -- Delete all frames if none have been taken: delete the dataset as well.
    PERFORM skey FROM px.shots WHERE sdspid=token and sstate='Done' limit 1;
    IF NOT FOUND THEN
      DELETE FROM px.shots WHERE sdspid=token;
      DELETE FROM px.datasets WHERE dspid=token;
    END IF;

    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.newdataset(token text) OWNER TO lsadmin;

--
-- Name: next_prefix(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION next_prefix(prefix text) RETURNS text
    AS $$
  DECLARE
    nexti int;
    rtn   text;
  BEGIN

    rtn := rtrim(prefix,'0123456789');

    SELECT INTO nexti max(coalesce(substr( dsfp, length(rtrim(dsfp,'0123456789'))+1)::int,0)) FROM px.datasets WHERE dsfp similar to replace(rtn,'_','\\_') || '[0-9]+';
    IF FOUND AND nexti is not null THEN
      nexti := nexti + 1;
      rtn := rtn || nexti;
    ELSE
      rtn := prefix || '_1';
    END IF;

    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.next_prefix(prefix text) OWNER TO lsadmin;

--
-- Name: nextshot(); Type: FUNCTION; Schema: px; Owner: brister
--

CREATE FUNCTION nextshot() RETURNS SETOF nextshottype
    AS $$
  DECLARE
    rtn px.nextshottype;        -- the return value                                                                                                                                                                                                                                    
    rq  record;                 -- the runqueue record at the top of the queueu                                                                                                                                                                                                        
  BEGIN

   SELECT INTO rq * FROM px.runqueue WHERE rqStn=px.getStation() ORDER BY rqOrder ASC LIMIT 1;
    IF FOUND THEN
      SELECT INTO rtn dsdir, dspid, dsowidth, dsoscaxis, dsexp, skey, sstart, sfn, dsphi, dsomega, dskappa, dsdist, dsnrg
        FROM px.datasets
        LEFT JOIN  px.shots ON dspid=sdspid and stype=rq.rqType
        WHERE dspid=rq.rqToken and sstate != 'Done'
        ORDER BY sindex ASC
        LIMIT 1;
      IF NOT FOUND THEN
        PERFORM px.poprunqueue();
        SELECT INTO rtn * from px.nextshot();
        IF NOT FOUND THEN
          RETURN;
        END IF;
      END IF;
      RETURN NEXT rtn;
    END IF;
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.nextshot() OWNER TO brister;

--
-- Name: pauserequest(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION pauserequest() RETURNS void
    AS $$
  DECLARE
    ntfy text;
  BEGIN
    PERFORM 1 FROM px.pause where pStn=px.getstation();
    IF FOUND THEN
      UPDATE px.pause set ptc=now(), pps='Please Pause';
    ELSE
      INSERT INTO px.pause (ptc,pStn,pps) VALUES (now(),px.getStation(),'Please Pause');
    END IF;
    SELECT INTO ntfy cnotifypause FROM px._config LEFT JOIN px.stations ON cstation=stnname WHERE stnkey=px.getstation();
    EXECUTE 'NOTIFY ' || ntfy;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.pauserequest() OWNER TO lsadmin;

--
-- Name: pauserequest(bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION pauserequest(stn bigint) RETURNS void
    AS $$
  DECLARE
    ntfy text;
  BEGIN
    PERFORM 1 FROM px.pause where pStn=stn;
    IF FOUND THEN
      UPDATE px.pause set ptc=now(), pps='Please Pause';
    ELSE
      INSERT INTO px.pause (ptc,pStn,pps) VALUES (now(),stn,'Please Pause');
    END IF;
    SELECT INTO ntfy cnotifypause FROM px._config LEFT JOIN px.stations ON cstation=stnname WHERE stnkey=stn;
    EXECUTE 'NOTIFY ' || ntfy;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.pauserequest(stn bigint) OWNER TO lsadmin;

--
-- Name: pausetell(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION pausetell() RETURNS void
    AS $$
  DECLARE
  BEGIN
    PERFORM 1 FROM px.pause where pStn=px.getstation();
    IF FOUND THEN
      UPDATE px.pause set ptc=now(), pps='I Paused';
    ELSE
      INSERT INTO px.pause (ptc,pStn,pps) VALUES (now(),px.getStation(),'I Paused');
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.pausetell() OWNER TO lsadmin;

--
-- Name: popqueue(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION popqueue() RETURNS text
    AS $$
--
-- Function to pop command off the queue
--
  DECLARE
    rtn text;	-- return value
    mqk int;    -- serial number of returned value
  BEGIN
    SELECT INTO rtn, mqk mqcmd, mqkey FROM px._marqueue where mqc=inet_client_addr() ORDER BY mqkey ASC LIMIT 1;
    IF NOT FOUND THEN
      RETURN '';
    END IF;
    DELETE FROM px._marqueue WHERE mqkey = mqk;
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.popqueue() OWNER TO lsadmin;

--
-- Name: popqueue(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION popqueue(cmd text) RETURNS text
    AS $$
--
-- Function to pop a specific command off the queue, even if it's not next
--
  DECLARE
    rtn text;	-- return value
    mqk int;    -- serial number of returned value
  BEGIN
    SELECT INTO rtn, mqk mqcmd, mqkey FROM px._marqueue WHERE mqcmd=cmd and mqc=inet_client_addr() ORDER BY mqkey ASC LIMIT 1;
    IF NOT FOUND THEN
      RETURN '';
    END IF;
    DELETE FROM px._marqueue WHERE mqkey = mqk;
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.popqueue(cmd text) OWNER TO lsadmin;

--
-- Name: poprunqueue(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION poprunqueue() RETURNS void
    AS $$
  DECLARE
    rq record;	-- records to update
    i  int;     -- welecome to the new order
  BEGIN
    DELETE FROM px.runqueue WHERE rqKey IN (select rqKey from px.runqueue where rqStn=px.getstation() ORDER BY rqOrder ASC limit 1);
    i := 1;
    FOR rq IN SELECT * FROM px.runqueue WHERE rqStn=px.getstation() ORDER BY rqOrder ASC LOOP
      UPDATE px.runqueue set rqOrder=i WHERE rqKey=rq.rqKey;
      i := i+1;
    END LOOP;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.poprunqueue() OWNER TO lsadmin;

--
-- Name: pushqueue(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION pushqueue(cmd text) RETURNS void
    AS $$
--                                                                                                                                                                                                   
-- Function to push command onto the queue                                                                                                                                                           
--                                                                                                                                                                                                   
  DECLARE
    c text;     -- trimmed cmd                                                                                                                                                                       
    ntfy text;
  BEGIN
    SELECT INTO ntfy cnotifydetector FROM px._config LEFT JOIN px.stations ON cstation=stnname WHERE stnkey=px.getstation();
    c = trim( cmd);
    IF length( c) > 0 THEN
      INSERT INTO px._marqueue (mqcmd,mqc) SELECT c, cdetector from px._config where cdiffractometer=inet_client_addr() or cdetector=inet_client_addr() limit 1;
      EXECUTE 'NOTIFY ' || ntfy;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.pushqueue(cmd text) OWNER TO lsadmin;

--
-- Name: pushqueue(text, inet); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION pushqueue(cmd text, ca inet) RETURNS void
    AS $$
--                                                                                                                                                                                                   
-- specify client address (ca) to queue up                                                                                                                                                           
  DECLARE
    c text;     -- trimmed cmd                                                                                                                                                                       
    ntfy text;
  BEGIN
    SELECT INTO ntfy cnotifydetector FROM px._config LEFT JOIN px.stations ON cstation=stnname WHERE stnkey=px.getstation();
    c = trim( cmd);
    IF length( c) > 0 THEN
      INSERT INTO px._marqueue (mqcmd,mqc) VALUES (c, ca);
      EXECUTE 'NOTIFY ' || ntfy;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.pushqueue(cmd text, ca inet) OWNER TO lsadmin;

--
-- Name: pushrunqueue(text, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION pushrunqueue(token text, stype text) RETURNS void
    AS $$
  DECLARE
  BEGIN
    PERFORM dskey FROM px.datasets WHERE dspid=token and dsdirs='Valid';
    IF FOUND THEN
      INSERT INTO px.runqueue (rqStn, rqToken, rqType, rqOrder) VALUES ( px.getstation(), token, stype, (SELECT coalesce(max(rqOrder),0)+1 FROM px.runqueue WHERE rqStn=px.getStation()));
      PERFORM 1 FROM px.pause WHERE pStn=px.getstation() and pps='Not Paused';
      IF FOUND THEN
        PERFORM px.startrun();
      END IF;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.pushrunqueue(token text, stype text) OWNER TO lsadmin;

--
-- Name: retake(integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION retake(thekey integer) RETURNS void
    AS $$
  DECLARE
    token text;         -- the token (for adding to queue)                                                                                                                                                                  
    typ   text;         -- need the type to startup snaps (not normal)                                                                                                                                                      
  BEGIN
    SELECT INTO token,typ sdspid,stype FROM px.shots WHERE skey=theKey;
    UPDATE px.shots SET sstate='NotTaken' WHERE skey=theKey;
    PERFORM 1 from px.runqueue where rqToken=token and rqType=typ;
    IF NOT FOUND THEN
      PERFORM px.pushrunqueue( token, typ);
    END IF;
--    IF typ = 'snap' THEN                                                                                                                                                                                                  
--      PERFORM px.startrun();                                                                                                                                                                                              
--    END IF;                                                                                                                                                                                                               
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.retake(thekey integer) OWNER TO lsadmin;

--
-- Name: retakerest(integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION retakerest(thekey integer) RETURNS void
    AS $$
  DECLARE
    ndx int;    -- starting index                                                                                                                                                                                           
    typ text;   -- type of shot                                                                                                                                                                                             
    token text; -- the pid                                                                                                                                                                                                  
  BEGIN
    SELECT INTO ndx,typ,token sindex,stype,sdspid FROM px.shots WHERE skey=theKey;
    UPDATE px.shots SET sstate='NotTaken' WHERE sdspid=token and sindex >= ndx and stype=typ;
    PERFORM px.pushrunqueue( token, typ);
--    IF typ = 'snap' THEN                                                                                                                                                                                                  
--      PERFORM px.startrun();                                                                                                                                                                                              
--    END IF;                                                                                                                                                                                                               
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.retakerest(thekey integer) OWNER TO lsadmin;

--
-- Name: rt_close_ss(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_close_ss() RETURNS void
    AS $$
--
-- Close Station Shutter
  DECLARE
  BEGIN
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_close_ss() OWNER TO lsadmin;

--
-- Name: rt_get_blstatus(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_get_blstatus() RETURNS text
    AS $$
--
-- Beamline status
  DECLARE
  BEGIN
    RETURN 'No Beam Today';
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_get_blstatus() OWNER TO lsadmin;

--
-- Name: rt_get_dist(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_get_dist() RETURNS text
    AS $$
  DECLARE
    rtn text;   -- return value                                                                                                                                                                      
  BEGIN
    SELECT INTO rtn to_char( mactpos, '9999.9') FROM epics.motions LEFT JOIN  px.epicsLink ON elPV=mmotorpvname WHERE elStn=px.getstation() and elName='distance';
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_get_dist() OWNER TO lsadmin;

--
-- Name: rt_get_energy(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_get_energy() RETURNS text
    AS $$
  DECLARE
    rtn text;
  BEGIN
    SELECT INTO rtn to_char(eluValue, '99.99999') FROM px.energyLookUp WHERE eluStn=px.getStation();
    IF NOT FOUND THEN
      rtn := '12.73';
    END IF;
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_get_energy() OWNER TO lsadmin;

--
-- Name: rt_get_ni0(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_get_ni0() RETURNS text
    AS $$
--                                                                                                                                                                                                   
-- Normalized Io                                                                                                                                                                                     
  DECLARE
    theCurrent numeric;
    theIzero   numeric;
    rtn        text;
  BEGIN
    SELECT INTO theCurrent pvmvaluen FROM epics._pvmonitors WHERE pvmname='S:SRcurrentAI';
    SELECT INTO theIzero  pvmvaluen FROM epics._pvmonitors LEFT JOIN px.epicsPVMLink ON epvmlPV=pvmname WHERE epvmlStn=px.getstation() and epvmlName='Io';

    IF theCurrent < 10.0 THEN
      rtn := '--';
    ELSE
      SELECT INTO rtn to_char( theIzero/theCurrent, '999999');
    END IF;
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_get_ni0() OWNER TO lsadmin;

--
-- Name: rt_get_wavelength(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_get_wavelength() RETURNS text
    AS $$
  DECLARE
    rtn text;
  BEGIN
    SELECT INTO rtn to_char(12.3984172/eluValue, '0.99999') FROM px.energyLookUp WHERE eluStn=px.getStation();
    IF NOT FOUND THEN
      rtn := '0.9747';
    END IF;
    RETURN rtn;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_get_wavelength() OWNER TO lsadmin;

--
-- Name: rt_open_fes(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_open_fes() RETURNS void
    AS $$
--
-- Open Front End Shutter
  DECLARE
  BEGIN
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_open_fes() OWNER TO lsadmin;

--
-- Name: rt_open_ss(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_open_ss() RETURNS void
    AS $$
--
-- Open Station Shutter
  DECLARE
  BEGIN
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_open_ss() OWNER TO lsadmin;

--
-- Name: rt_set_dist(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_set_dist(d text) RETURNS void
    AS $$
  DECLARE
  BEGIN
    -- PERFORM px.moveit( 'distance', d::numeric);                                                                                                                                                                                             
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_set_dist(d text) OWNER TO lsadmin;

--
-- Name: rt_set_energy(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_set_energy(e text) RETURNS void
    AS $$
  DECLARE
  BEGIN
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_set_energy(e text) OWNER TO lsadmin;

--
-- Name: rt_set_wavelength(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION rt_set_wavelength(lambda text) RETURNS void
    AS $$
  DECLARE
  BEGIN
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.rt_set_wavelength(lambda text) OWNER TO lsadmin;

--
-- Name: runqueue_delete_tf(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION runqueue_delete_tf() RETURNS "trigger"
    AS $$
  DECLARE
  BEGIN
    PERFORM 1 FROM px.runqueue WHERE rqStn=px.getstation();
    IF NOT FOUND THEN
      PERFORM px.unpause();
    END IF;
    RETURN NULL;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.runqueue_delete_tf() OWNER TO lsadmin;

--
-- Name: runqueue_down(bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION runqueue_down(thekey bigint) RETURNS void
    AS $$
--
-- Move item down the runqueue (raise its order) by swapping with the next higher one
--
  DECLARE
    mx  int;    -- maximum value of the run queue order
    a   record;	-- the record we'd like to move
  BEGIN
    SELECT INTO mx max(rqOrder) FROM px.runqueue WHERE rqStn=px.getStation();
    SELECT INTO a * FROM px.runqueue WHERE rqKey=theKey;
    IF FOUND and a.rqOrder < mx THEN
      UPDATE px.runqueue SET rqOrder=(SELECT max(rqOrder)+1 FROM px.runqueue WHERE rqStn=px.getStation())  WHERE rqKey=a.rqKey;
      UPDATE px.runqueue SET rqOrder=a.rqOrder   WHERE rqOrder = a.rqOrder+1 and rqStn=px.getStation();
      UPDATE px.runqueue SET rqOrder=a.rqOrder+1 WHERE rqKey=a.rqKey;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.runqueue_down(thekey bigint) OWNER TO lsadmin;

--
-- Name: runqueue_get(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION runqueue_get() RETURNS SETOF runqueuetype
    AS $$
  DECLARE
    rtn px.runqueuetype;		-- the return value
    rq record;				-- the runqueue entry
    startTime timestamp with time zone;	-- start time of next dataset
    deltaTime interval;			-- estimated time for this dataset
  BEGIN
    startTime := now();
    FOR rq IN SELECT * FROM px.runqueue WHERE rqStn=px.getStation() ORDER BY rqOrder LOOP
      deltaTime := px.ds_get_et( rq.rqToken, rq.rqType);
      startTime := startTime + deltaTime;
      rtn.etc   := to_char( startTime, 'HH24:MI');
      rtn.dspid := rq.rqToken;
      rtn.type  := rq.rqType;
      rtn.k     := rq.rqKey;
      RETURN NEXT rtn;
    END LOOP;
    RETURN;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.runqueue_get() OWNER TO lsadmin;

--
-- Name: runqueue_remove(bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION runqueue_remove(k bigint) RETURNS void
    AS $$
  DECLARE
    ordr int;	-- the order of the item we are removing
  BEGIN
    SELECT INTO ordr rqOrder FROM px.runqueue WHERE rqKey=k and rqStn=px.getStation();
    DELETE FROM px.runqueue WHERE rqKey=k and rqStn=px.getStation();
    UPDATE px.runqueue SET rqOrder=rqOrder-1 WHERE rqOrder > ordr;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.runqueue_remove(k bigint) OWNER TO lsadmin;

--
-- Name: runqueue_up(bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION runqueue_up(thekey bigint) RETURNS void
    AS $$
--
-- Move item up the runqueue (lower its order) by swapping with the next lower one
--
  DECLARE
    a   record;	-- entry of the one we'd like to move
  BEGIN
    SELECT INTO a * FROM px.runqueue WHERE rqKey=theKey and rqStn = px.getStation();
    IF FOUND and a.rqOrder>1 THEN
      UPDATE px.runqueue SET rqOrder=(SELECT max(rqOrder)+1 FROM px.runqueue WHERE rqStn=px.getStation())  WHERE rqKey=a.rqKey;
      UPDATE px.runqueue SET rqOrder=a.rqOrder   WHERE rqOrder = a.rqOrder-1 and rqStn=px.getStation();
      UPDATE px.runqueue SET rqOrder=a.rqOrder-1 WHERE rqKey=a.rqKey;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.runqueue_up(thekey bigint) OWNER TO lsadmin;

--
-- Name: runqueuecount(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION runqueuecount() RETURNS integer
    AS $$
  SELECT count(*)::int FROM px.runqueue WHERE rqStn=px.getstation();
$$
    LANGUAGE sql SECURITY DEFINER;


ALTER FUNCTION px.runqueuecount() OWNER TO lsadmin;

--
-- Name: shot_set_axis(text, text, integer, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_axis(pid text, "type" text, i integer, arg_1 text) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET saxis=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_axis(pid text, "type" text, i integer, arg_1 text) OWNER TO lsadmin;

--
-- Name: shot_set_comment(text, text, integer, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_comment(pid text, "type" text, i integer, arg_1 text) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET scmt=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_comment(pid text, "type" text, i integer, arg_1 text) OWNER TO lsadmin;

--
-- Name: shot_set_dist(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_dist(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET sdist=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_dist(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shot_set_energy(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_energy(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET snrg=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_energy(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shot_set_expt(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_expt(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET sexpt=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_expt(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shot_set_expu(text, text, integer, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_expu(pid text, "type" text, i integer, arg_1 text) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET expu=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_expu(pid text, "type" text, i integer, arg_1 text) OWNER TO lsadmin;

--
-- Name: shot_set_fn(text, text, integer, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_fn(pid text, "type" text, i integer, arg_1 text) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET sfn=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_fn(pid text, "type" text, i integer, arg_1 text) OWNER TO lsadmin;

--
-- Name: shot_set_kappa(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_kappa(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET skappa=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_kappa(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shot_set_omega(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_omega(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET somega=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_omega(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shot_set_phi(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_phi(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET phi=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_phi(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shot_set_start(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_start(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET sstart=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_start(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shot_set_state(text, text, integer, text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_state(pid text, "type" text, i integer, arg_1 text) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET sstate=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_state(pid text, "type" text, i integer, arg_1 text) OWNER TO lsadmin;

--
-- Name: shot_set_width(text, text, integer, numeric); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shot_set_width(pid text, "type" text, i integer, arg_1 numeric) RETURNS void
    AS $$
  BEGIN UPDATE px.shots SET swidth=arg_1 where sdspid=pid and stype=type and sindex=i; END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shot_set_width(pid text, "type" text, i integer, arg_1 numeric) OWNER TO lsadmin;

--
-- Name: shots_set_expose(integer); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION shots_set_expose(thekey integer) RETURNS void
    AS $$
  DECLARE
    ds record;	-- the dataset record
    token text;	-- the record token
  BEGIN
    SELECT INTO token sdspid FROM px.shots WHERE skey=theKey;
    IF FOUND THEN
      SELECT INTO ds * FROM px.datasets WHERE dspid=token;
      UPDATE px.shots SET saxis=ds.dsoscaxis, swidth=ds.dsowidth, sexpt=ds.dsexp, sexpu=ds.dsexpunit, somega=ds.dsstart,sstate='Exposing' WHERE skey=theKey;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shots_set_expose(thekey integer) OWNER TO lsadmin;

--
-- Name: shotsupdatetf(); Type: FUNCTION; Schema: px; Owner: brister
--

CREATE FUNCTION shotsupdatetf() RETURNS "trigger"
    AS $$
  DECLARE
  BEGIN
    IF NEW.sstate = 'Done' THEN
      PERFORM 1 FROM px.shots WHERE sdspid=NEW.sdspid and stype=NEW.stype and sstate!='Done' and sKey != NEW.sKey;
      IF NOT FOUND THEN
        PERFORM px.poprunqueue();
      END IF;
    END IF;
  RETURN NULL;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.shotsupdatetf() OWNER TO brister;

--
-- Name: startrun(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION startrun() RETURNS void
    AS $$
  DECLARE
    nt text;    -- notify condition                                                                                                                                                                                         
  BEGIN
    SELECT INTO nt cnotifyrun FROM px._config left join px.stations on stnname=cstation WHERE stnkey=px.getstation();
    IF FOUND THEN
      UPDATE px.pause SET ptc=now(), pps='Not Paused' WHERE pStn=px.getStation();
      EXECUTE 'NOTIFY ' || nt;
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.startrun() OWNER TO lsadmin;

--
-- Name: startsnap(text); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION startsnap(token text) RETURNS void
    AS $$
  DECLARE
    ntfy text;
  BEGIN
    SELECT INTO ntfy cnotifydetector FROM px._config LEFT JOIN px.stations ON cstation=stnname WHERE stnkey=px.getstation();
    EXECUTE 'NOTIFY ' || ntfy;
    return;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.startsnap(token text) OWNER TO lsadmin;

--
-- Name: unpause(); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION unpause() RETURNS void
    AS $$
  DECLARE
  BEGIN
    PERFORM 1 FROM px.pause where pStn=px.getstation();
    IF FOUND THEN
      UPDATE px.pause set ptc=now(), pps='Not Paused';
    ELSE
      INSERT INTO px.pause (ptc,pStn,pps) VALUES (now(),px.getStation(),'Not Paused');
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.unpause() OWNER TO lsadmin;

--
-- Name: unpause(bigint); Type: FUNCTION; Schema: px; Owner: lsadmin
--

CREATE FUNCTION unpause(stn bigint) RETURNS void
    AS $$
  DECLARE
  BEGIN
    PERFORM 1 FROM px.pause where pStn=stn;
    IF FOUND THEN
      UPDATE px.pause set ptc=now(), pps='Not Paused';
    ELSE
      INSERT INTO px.pause (ptc,pStn,pps) VALUES (now(), stn,'Not Paused');
    END IF;
  END;
$$
    LANGUAGE plpgsql SECURITY DEFINER;


ALTER FUNCTION px.unpause(stn bigint) OWNER TO lsadmin;

--
-- Name: _config; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _config (
    ckey integer NOT NULL,
    cdetector inet NOT NULL,
    cdiffractometer inet NOT NULL,
    cstation text,
    cdifflocktable text NOT NULL,
    cdetectlocktable text NOT NULL,
    cnotifykill text NOT NULL,
    cnotifysnap text NOT NULL,
    cnotifyrun text NOT NULL,
    cnotifydetector text DEFAULT 'martest'::text NOT NULL,
    cnotifypause text
);


ALTER TABLE px._config OWNER TO lsadmin;

--
-- Name: _config_ckey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE _config_ckey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px._config_ckey_seq OWNER TO lsadmin;

--
-- Name: _config_ckey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE _config_ckey_seq OWNED BY _config.ckey;


--
-- Name: _energyhistory; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _energyhistory (
    ehkey integer NOT NULL,
    ehts timestamp with time zone DEFAULT now(),
    ehstn bigint NOT NULL,
    ehvalue numeric
);


ALTER TABLE px._energyhistory OWNER TO lsadmin;

--
-- Name: _energyhistory_ehkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE _energyhistory_ehkey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px._energyhistory_ehkey_seq OWNER TO lsadmin;

--
-- Name: _energyhistory_ehkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE _energyhistory_ehkey_seq OWNED BY _energyhistory.ehkey;


--
-- Name: _energylookup; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _energylookup (
    elukey integer NOT NULL,
    elustn bigint,
    elutype text,
    eluepics text
);


ALTER TABLE px._energylookup OWNER TO lsadmin;

--
-- Name: _energylookup_elukey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE _energylookup_elukey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px._energylookup_elukey_seq OWNER TO lsadmin;

--
-- Name: _energylookup_elukey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE _energylookup_elukey_seq OWNED BY _energylookup.elukey;


--
-- Name: _energylookupmethods; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _energylookupmethods (
    elum text NOT NULL
);


ALTER TABLE px._energylookupmethods OWNER TO lsadmin;

--
-- Name: _id21d_detectorlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21d_detectorlock (
    d integer
);


ALTER TABLE px._id21d_detectorlock OWNER TO lsadmin;

--
-- Name: _id21d_diffractometerlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21d_diffractometerlock (
    d integer
);


ALTER TABLE px._id21d_diffractometerlock OWNER TO lsadmin;

--
-- Name: _id21e_detectorlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21e_detectorlock (
    d integer
);


ALTER TABLE px._id21e_detectorlock OWNER TO lsadmin;

--
-- Name: _id21e_diffractometerlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21e_diffractometerlock (
    d integer
);


ALTER TABLE px._id21e_diffractometerlock OWNER TO lsadmin;

--
-- Name: _id21f_detectorlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21f_detectorlock (
    d integer
);


ALTER TABLE px._id21f_detectorlock OWNER TO lsadmin;

--
-- Name: _id21f_diffractometerlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21f_diffractometerlock (
    d integer
);


ALTER TABLE px._id21f_diffractometerlock OWNER TO lsadmin;

--
-- Name: _id21g_detectorlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21g_detectorlock (
    d integer
);


ALTER TABLE px._id21g_detectorlock OWNER TO lsadmin;

--
-- Name: _id21g_diffractometerlock; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _id21g_diffractometerlock (
    d integer
);


ALTER TABLE px._id21g_diffractometerlock OWNER TO lsadmin;

--
-- Name: _mar; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _mar (
    mkey integer NOT NULL,
    mc inet NOT NULL,
    mts timestamp with time zone DEFAULT now(),
    mtu timestamp with time zone DEFAULT now(),
    mrawresponse text,
    mcnt integer DEFAULT 1,
    mrawstate integer
);


ALTER TABLE px._mar OWNER TO lsadmin;

--
-- Name: _mar_mkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE _mar_mkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px._mar_mkey_seq OWNER TO lsadmin;

--
-- Name: _mar_mkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE _mar_mkey_seq OWNED BY _mar.mkey;


--
-- Name: _marinit; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _marinit (
    mikey integer NOT NULL,
    miitem text NOT NULL,
    miorder integer
);


ALTER TABLE px._marinit OWNER TO lsadmin;

--
-- Name: _marinit_mikey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE _marinit_mikey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px._marinit_mikey_seq OWNER TO lsadmin;

--
-- Name: _marinit_mikey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE _marinit_mikey_seq OWNED BY _marinit.mikey;


--
-- Name: _marqueue; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE _marqueue (
    mqkey integer NOT NULL,
    mqs timestamp with time zone DEFAULT now(),
    mqc inet NOT NULL,
    mqcmd text NOT NULL
);


ALTER TABLE px._marqueue OWNER TO lsadmin;

--
-- Name: _marqueue_mqkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE _marqueue_mqkey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px._marqueue_mqkey_seq OWNER TO lsadmin;

--
-- Name: _marqueue_mqkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE _marqueue_mqkey_seq OWNED BY _marqueue.mqkey;


--
-- Name: axes; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE axes (
    akey integer NOT NULL,
    aaxis text NOT NULL,
    aepics text,
    astn integer
);


ALTER TABLE px.axes OWNER TO lsadmin;

--
-- Name: axes_akey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE axes_akey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.axes_akey_seq OWNER TO lsadmin;

--
-- Name: axes_akey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE axes_akey_seq OWNED BY axes.akey;


--
-- Name: datasets_dskey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE datasets_dskey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.datasets_dskey_seq OWNER TO lsadmin;

--
-- Name: datasets_dskey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE datasets_dskey_seq OWNED BY datasets.dskey;


--
-- Name: dirstates; Type: TABLE; Schema: px; Owner: brister; Tablespace: 
--

CREATE TABLE dirstates (
    dirs text NOT NULL
);


ALTER TABLE px.dirstates OWNER TO brister;

--
-- Name: distsaves; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE distsaves (
    dskey integer NOT NULL,
    dsstn bigint,
    dsts timestamp with time zone,
    dsin numeric DEFAULT 500,
    dsout numeric DEFAULT 500
);


ALTER TABLE px.distsaves OWNER TO lsadmin;

--
-- Name: distsaves_dskey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE distsaves_dskey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.distsaves_dskey_seq OWNER TO lsadmin;

--
-- Name: distsaves_dskey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE distsaves_dskey_seq OWNED BY distsaves.dskey;


--
-- Name: dsstates; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE dsstates (
    dss text NOT NULL
);


ALTER TABLE px.dsstates OWNER TO lsadmin;

--
-- Name: energylookup; Type: VIEW; Schema: px; Owner: lsadmin
--

CREATE VIEW energylookup AS
    SELECT _energylookup.elukey, _energylookup.elustn, CASE _energylookup.elutype WHEN 'table'::text THEN _energyhistory.ehvalue WHEN 'epics'::text THEN _pvmonitors.pvmvaluen ELSE NULL::numeric END AS eluvalue FROM ((_energylookup LEFT JOIN _energyhistory ON ((_energylookup.elustn = _energyhistory.ehstn))) LEFT JOIN epics._pvmonitors ON ((_energylookup.eluepics = _pvmonitors.pvmname))) WHERE ((_energyhistory.ehkey IN (SELECT max(_energyhistory.ehkey) AS max FROM _energyhistory GROUP BY _energyhistory.ehstn)) OR (_pvmonitors.pvmkey IS NOT NULL));


ALTER TABLE px.energylookup OWNER TO lsadmin;

--
-- Name: epicslink; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE epicslink (
    elkey integer NOT NULL,
    elstn bigint,
    elname text NOT NULL,
    elpv text NOT NULL
);


ALTER TABLE px.epicslink OWNER TO lsadmin;

--
-- Name: epicslink_elkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE epicslink_elkey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.epicslink_elkey_seq OWNER TO lsadmin;

--
-- Name: epicslink_elkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE epicslink_elkey_seq OWNED BY epicslink.elkey;


--
-- Name: epicspvmlink; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE epicspvmlink (
    epvmlkey integer NOT NULL,
    epvmlstn bigint,
    epvmlname text NOT NULL,
    epvmlpv text NOT NULL
);


ALTER TABLE px.epicspvmlink OWNER TO lsadmin;

--
-- Name: epicspvmlink_epvmlkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE epicspvmlink_epvmlkey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.epicspvmlink_epvmlkey_seq OWNER TO lsadmin;

--
-- Name: epicspvmlink_epvmlkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE epicspvmlink_epvmlkey_seq OWNED BY epicspvmlink.epvmlkey;


--
-- Name: expunits; Type: TABLE; Schema: px; Owner: brister; Tablespace: 
--

CREATE TABLE expunits (
    eu text NOT NULL,
    eus text
);


ALTER TABLE px.expunits OWNER TO brister;

--
-- Name: mar; Type: VIEW; Schema: px; Owner: brister
--

CREATE VIEW mar AS
    SELECT _mar.mkey, host(_mar.mc) AS mqc, _mar.mts, _mar.mtu, (_mar.mtu - _mar.mts) AS mtd, marstatus(_mar.mrawstate) AS mstatus, martaskstatus(_mar.mrawstate, 0) AS maquire, martaskstatus(_mar.mrawstate, 1) AS mread, martaskstatus(_mar.mrawstate, 2) AS mcorrect, martaskstatus(_mar.mrawstate, 3) AS mwrite, martaskstatus(_mar.mrawstate, 4) AS mdezinger FROM _mar;


ALTER TABLE px.mar OWNER TO brister;

--
-- Name: oscsenses; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE oscsenses (
    os text NOT NULL
);


ALTER TABLE px.oscsenses OWNER TO lsadmin;

--
-- Name: pause; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE pause (
    pkey integer NOT NULL,
    ptc timestamp with time zone DEFAULT now(),
    pstn integer,
    pps text
);


ALTER TABLE px.pause OWNER TO lsadmin;

--
-- Name: pause_pkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE pause_pkey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.pause_pkey_seq OWNER TO lsadmin;

--
-- Name: pause_pkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE pause_pkey_seq OWNED BY pause.pkey;


--
-- Name: pausestates; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE pausestates (
    pss text NOT NULL
);


ALTER TABLE px.pausestates OWNER TO lsadmin;

--
-- Name: runqueue; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE runqueue (
    rqkey integer NOT NULL,
    rqstn integer,
    rqcts timestamp with time zone DEFAULT now(),
    rqorder integer NOT NULL,
    rqtoken text NOT NULL,
    rqtype text NOT NULL
);


ALTER TABLE px.runqueue OWNER TO lsadmin;

--
-- Name: runqueue_rqkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE runqueue_rqkey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.runqueue_rqkey_seq OWNER TO lsadmin;

--
-- Name: runqueue_rqkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE runqueue_rqkey_seq OWNED BY runqueue.rqkey;


--
-- Name: shots_skey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE shots_skey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.shots_skey_seq OWNER TO lsadmin;

--
-- Name: shots_skey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE shots_skey_seq OWNED BY shots.skey;


--
-- Name: shotstates; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE shotstates (
    ssstate text NOT NULL
);


ALTER TABLE px.shotstates OWNER TO lsadmin;

--
-- Name: stations; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE stations (
    stnkey integer NOT NULL,
    stnname text NOT NULL,
    stnshortname text NOT NULL,
    stndataroot text NOT NULL
);


ALTER TABLE px.stations OWNER TO lsadmin;

--
-- Name: stations_stnkey_seq; Type: SEQUENCE; Schema: px; Owner: lsadmin
--

CREATE SEQUENCE stations_stnkey_seq
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE px.stations_stnkey_seq OWNER TO lsadmin;

--
-- Name: stations_stnkey_seq; Type: SEQUENCE OWNED BY; Schema: px; Owner: lsadmin
--

ALTER SEQUENCE stations_stnkey_seq OWNED BY stations.stnkey;


--
-- Name: stypes; Type: TABLE; Schema: px; Owner: lsadmin; Tablespace: 
--

CREATE TABLE stypes (
    st text NOT NULL
);


ALTER TABLE px.stypes OWNER TO lsadmin;

--
-- Name: ckey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE _config ALTER COLUMN ckey SET DEFAULT nextval('_config_ckey_seq'::regclass);


--
-- Name: ehkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE _energyhistory ALTER COLUMN ehkey SET DEFAULT nextval('_energyhistory_ehkey_seq'::regclass);


--
-- Name: elukey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE _energylookup ALTER COLUMN elukey SET DEFAULT nextval('_energylookup_elukey_seq'::regclass);


--
-- Name: mkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE _mar ALTER COLUMN mkey SET DEFAULT nextval('_mar_mkey_seq'::regclass);


--
-- Name: mikey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE _marinit ALTER COLUMN mikey SET DEFAULT nextval('_marinit_mikey_seq'::regclass);


--
-- Name: mqkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE _marqueue ALTER COLUMN mqkey SET DEFAULT nextval('_marqueue_mqkey_seq'::regclass);


--
-- Name: akey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE axes ALTER COLUMN akey SET DEFAULT nextval('axes_akey_seq'::regclass);


--
-- Name: dskey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE datasets ALTER COLUMN dskey SET DEFAULT nextval('datasets_dskey_seq'::regclass);


--
-- Name: dskey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE distsaves ALTER COLUMN dskey SET DEFAULT nextval('distsaves_dskey_seq'::regclass);


--
-- Name: elkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE epicslink ALTER COLUMN elkey SET DEFAULT nextval('epicslink_elkey_seq'::regclass);


--
-- Name: epvmlkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE epicspvmlink ALTER COLUMN epvmlkey SET DEFAULT nextval('epicspvmlink_epvmlkey_seq'::regclass);


--
-- Name: pkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE pause ALTER COLUMN pkey SET DEFAULT nextval('pause_pkey_seq'::regclass);


--
-- Name: rqkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE runqueue ALTER COLUMN rqkey SET DEFAULT nextval('runqueue_rqkey_seq'::regclass);


--
-- Name: skey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE shots ALTER COLUMN skey SET DEFAULT nextval('shots_skey_seq'::regclass);


--
-- Name: stnkey; Type: DEFAULT; Schema: px; Owner: lsadmin
--

ALTER TABLE stations ALTER COLUMN stnkey SET DEFAULT nextval('stations_stnkey_seq'::regclass);


--
-- Name: _config_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _config
    ADD CONSTRAINT _config_pkey PRIMARY KEY (ckey);


--
-- Name: _energyhistory_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _energyhistory
    ADD CONSTRAINT _energyhistory_pkey PRIMARY KEY (ehkey);


--
-- Name: _energylookup_elustn_key; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _energylookup
    ADD CONSTRAINT _energylookup_elustn_key UNIQUE (elustn);


--
-- Name: _energylookup_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _energylookup
    ADD CONSTRAINT _energylookup_pkey PRIMARY KEY (elukey);


--
-- Name: _energylookupmethods_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _energylookupmethods
    ADD CONSTRAINT _energylookupmethods_pkey PRIMARY KEY (elum);


--
-- Name: _mar_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _mar
    ADD CONSTRAINT _mar_pkey PRIMARY KEY (mkey);


--
-- Name: _marinit_miorder_key; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _marinit
    ADD CONSTRAINT _marinit_miorder_key UNIQUE (miorder);


--
-- Name: _marinit_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _marinit
    ADD CONSTRAINT _marinit_pkey PRIMARY KEY (mikey);


--
-- Name: _marqueue_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY _marqueue
    ADD CONSTRAINT _marqueue_pkey PRIMARY KEY (mqkey);


--
-- Name: axes_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY axes
    ADD CONSTRAINT axes_pkey PRIMARY KEY (akey);


--
-- Name: datasets_dspid_key; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY datasets
    ADD CONSTRAINT datasets_dspid_key UNIQUE (dspid);


--
-- Name: datasets_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY datasets
    ADD CONSTRAINT datasets_pkey PRIMARY KEY (dskey);


--
-- Name: dirstates_pkey; Type: CONSTRAINT; Schema: px; Owner: brister; Tablespace: 
--

ALTER TABLE ONLY dirstates
    ADD CONSTRAINT dirstates_pkey PRIMARY KEY (dirs);


--
-- Name: distsaves_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY distsaves
    ADD CONSTRAINT distsaves_pkey PRIMARY KEY (dskey);


--
-- Name: dsstates_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY dsstates
    ADD CONSTRAINT dsstates_pkey PRIMARY KEY (dss);


--
-- Name: epicslink_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY epicslink
    ADD CONSTRAINT epicslink_pkey PRIMARY KEY (elkey);


--
-- Name: epicspvmlink_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY epicspvmlink
    ADD CONSTRAINT epicspvmlink_pkey PRIMARY KEY (epvmlkey);


--
-- Name: expunits_eus_key; Type: CONSTRAINT; Schema: px; Owner: brister; Tablespace: 
--

ALTER TABLE ONLY expunits
    ADD CONSTRAINT expunits_eus_key UNIQUE (eus);


--
-- Name: expunits_pkey; Type: CONSTRAINT; Schema: px; Owner: brister; Tablespace: 
--

ALTER TABLE ONLY expunits
    ADD CONSTRAINT expunits_pkey PRIMARY KEY (eu);


--
-- Name: oscsenses_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY oscsenses
    ADD CONSTRAINT oscsenses_pkey PRIMARY KEY (os);


--
-- Name: pause_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY pause
    ADD CONSTRAINT pause_pkey PRIMARY KEY (pkey);


--
-- Name: pausestates_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY pausestates
    ADD CONSTRAINT pausestates_pkey PRIMARY KEY (pss);


--
-- Name: runqueue_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY runqueue
    ADD CONSTRAINT runqueue_pkey PRIMARY KEY (rqkey);


--
-- Name: runqueue_rqstn_key; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY runqueue
    ADD CONSTRAINT runqueue_rqstn_key UNIQUE (rqstn, rqorder);


--
-- Name: shots_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY shots
    ADD CONSTRAINT shots_pkey PRIMARY KEY (skey);


--
-- Name: shots_sdspid_key; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY shots
    ADD CONSTRAINT shots_sdspid_key UNIQUE (sdspid, stype, sindex);


--
-- Name: shotstates_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY shotstates
    ADD CONSTRAINT shotstates_pkey PRIMARY KEY (ssstate);


--
-- Name: stations_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY stations
    ADD CONSTRAINT stations_pkey PRIMARY KEY (stnkey);


--
-- Name: stations_stnname_key; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY stations
    ADD CONSTRAINT stations_stnname_key UNIQUE (stnname);


--
-- Name: stations_stnshortname_key; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY stations
    ADD CONSTRAINT stations_stnshortname_key UNIQUE (stnshortname);


--
-- Name: stypes_pkey; Type: CONSTRAINT; Schema: px; Owner: lsadmin; Tablespace: 
--

ALTER TABLE ONLY stypes
    ADD CONSTRAINT stypes_pkey PRIMARY KEY (st);


--
-- Name: _mar_insert_trigger; Type: TRIGGER; Schema: px; Owner: lsadmin
--

CREATE TRIGGER _mar_insert_trigger
    BEFORE INSERT ON _mar
    FOR EACH ROW
    EXECUTE PROCEDURE _mar_insert_tf();


--
-- Name: runqueue_delete_trigger; Type: TRIGGER; Schema: px; Owner: lsadmin
--

CREATE TRIGGER runqueue_delete_trigger
    AFTER DELETE ON runqueue
    FOR EACH STATEMENT
    EXECUTE PROCEDURE runqueue_delete_tf();


--
-- Name: shotsupdatetrigger; Type: TRIGGER; Schema: px; Owner: lsadmin
--

CREATE TRIGGER shotsupdatetrigger
    AFTER UPDATE ON shots
    FOR EACH ROW
    EXECUTE PROCEDURE shotsupdatetf();


--
-- Name: _config_cstation_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY _config
    ADD CONSTRAINT _config_cstation_fkey FOREIGN KEY (cstation) REFERENCES stations(stnname);


--
-- Name: _energyhistory_ehstn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY _energyhistory
    ADD CONSTRAINT _energyhistory_ehstn_fkey FOREIGN KEY (ehstn) REFERENCES stations(stnkey);


--
-- Name: _energylookup_eluepics_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY _energylookup
    ADD CONSTRAINT _energylookup_eluepics_fkey FOREIGN KEY (eluepics) REFERENCES epics._pvmonitors(pvmname) ON UPDATE CASCADE;


--
-- Name: _energylookup_elustn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY _energylookup
    ADD CONSTRAINT _energylookup_elustn_fkey FOREIGN KEY (elustn) REFERENCES stations(stnkey);


--
-- Name: _energylookup_elutype_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY _energylookup
    ADD CONSTRAINT _energylookup_elutype_fkey FOREIGN KEY (elutype) REFERENCES _energylookupmethods(elum) ON UPDATE CASCADE;


--
-- Name: axes_astn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY axes
    ADD CONSTRAINT axes_astn_fkey FOREIGN KEY (astn) REFERENCES stations(stnkey) ON UPDATE CASCADE;


--
-- Name: datasets_dsdirs_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY datasets
    ADD CONSTRAINT datasets_dsdirs_fkey FOREIGN KEY (dsdirs) REFERENCES dirstates(dirs);


--
-- Name: datasets_dsexpunit_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY datasets
    ADD CONSTRAINT datasets_dsexpunit_fkey FOREIGN KEY (dsexpunit) REFERENCES expunits(eu) ON UPDATE CASCADE;


--
-- Name: datasets_dsoscsense_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY datasets
    ADD CONSTRAINT datasets_dsoscsense_fkey FOREIGN KEY (dsoscsense) REFERENCES oscsenses(os) ON UPDATE CASCADE;


--
-- Name: datasets_dsstate_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY datasets
    ADD CONSTRAINT datasets_dsstate_fkey FOREIGN KEY (dsstate) REFERENCES dsstates(dss);


--
-- Name: datasets_dsstn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY datasets
    ADD CONSTRAINT datasets_dsstn_fkey FOREIGN KEY (dsstn) REFERENCES stations(stnkey) ON UPDATE CASCADE;


--
-- Name: distsaves_dsstn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY distsaves
    ADD CONSTRAINT distsaves_dsstn_fkey FOREIGN KEY (dsstn) REFERENCES stations(stnkey);


--
-- Name: epicslink_elpv_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY epicslink
    ADD CONSTRAINT epicslink_elpv_fkey FOREIGN KEY (elpv) REFERENCES epics._motions(mmotorpvname) ON UPDATE CASCADE;


--
-- Name: epicslink_elstn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY epicslink
    ADD CONSTRAINT epicslink_elstn_fkey FOREIGN KEY (elstn) REFERENCES stations(stnkey);


--
-- Name: epicspvmlink_epvmlpv_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY epicspvmlink
    ADD CONSTRAINT epicspvmlink_epvmlpv_fkey FOREIGN KEY (epvmlpv) REFERENCES epics._pvmonitors(pvmname) ON UPDATE CASCADE;


--
-- Name: epicspvmlink_epvmlstn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY epicspvmlink
    ADD CONSTRAINT epicspvmlink_epvmlstn_fkey FOREIGN KEY (epvmlstn) REFERENCES stations(stnkey);


--
-- Name: pause_pps_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY pause
    ADD CONSTRAINT pause_pps_fkey FOREIGN KEY (pps) REFERENCES pausestates(pss);


--
-- Name: pause_pstn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY pause
    ADD CONSTRAINT pause_pstn_fkey FOREIGN KEY (pstn) REFERENCES stations(stnkey);


--
-- Name: runqueue_rqstn_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY runqueue
    ADD CONSTRAINT runqueue_rqstn_fkey FOREIGN KEY (rqstn) REFERENCES stations(stnkey);


--
-- Name: runqueue_rqtoken_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY runqueue
    ADD CONSTRAINT runqueue_rqtoken_fkey FOREIGN KEY (rqtoken) REFERENCES datasets(dspid);


--
-- Name: runqueue_rqtype_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY runqueue
    ADD CONSTRAINT runqueue_rqtype_fkey FOREIGN KEY (rqtype) REFERENCES stypes(st);


--
-- Name: shots_sdspid_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY shots
    ADD CONSTRAINT shots_sdspid_fkey FOREIGN KEY (sdspid) REFERENCES datasets(dspid) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: shots_sexpu_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY shots
    ADD CONSTRAINT shots_sexpu_fkey FOREIGN KEY (sexpu) REFERENCES expunits(eu) ON UPDATE CASCADE;


--
-- Name: shots_sstate_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY shots
    ADD CONSTRAINT shots_sstate_fkey FOREIGN KEY (sstate) REFERENCES shotstates(ssstate) ON UPDATE CASCADE;


--
-- Name: shots_stype_fkey; Type: FK CONSTRAINT; Schema: px; Owner: lsadmin
--

ALTER TABLE ONLY shots
    ADD CONSTRAINT shots_stype_fkey FOREIGN KEY (stype) REFERENCES stypes(st) ON UPDATE CASCADE;


--
-- Name: px; Type: ACL; Schema: -; Owner: brister
--

REVOKE ALL ON SCHEMA px FROM PUBLIC;
REVOKE ALL ON SCHEMA px FROM brister;
GRANT ALL ON SCHEMA px TO brister;
GRANT USAGE ON SCHEMA px TO PUBLIC;


--
-- Name: datasets; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE datasets FROM PUBLIC;
REVOKE ALL ON TABLE datasets FROM lsadmin;
GRANT ALL ON TABLE datasets TO lsadmin;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE datasets TO PUBLIC;


--
-- Name: shots; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE shots FROM PUBLIC;
REVOKE ALL ON TABLE shots FROM lsadmin;
GRANT ALL ON TABLE shots TO lsadmin;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE shots TO PUBLIC;


--
-- Name: _config; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE _config FROM PUBLIC;
REVOKE ALL ON TABLE _config FROM lsadmin;
GRANT ALL ON TABLE _config TO lsadmin;
GRANT SELECT ON TABLE _config TO PUBLIC;


--
-- Name: _mar; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE _mar FROM PUBLIC;
REVOKE ALL ON TABLE _mar FROM lsadmin;
GRANT ALL ON TABLE _mar TO lsadmin;
GRANT SELECT,INSERT,UPDATE ON TABLE _mar TO PUBLIC;


--
-- Name: _mar_mkey_seq; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON SEQUENCE _mar_mkey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE _mar_mkey_seq FROM lsadmin;
GRANT SELECT,UPDATE ON SEQUENCE _mar_mkey_seq TO lsadmin;
GRANT SELECT,UPDATE ON SEQUENCE _mar_mkey_seq TO PUBLIC;


--
-- Name: axes; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE axes FROM PUBLIC;
REVOKE ALL ON TABLE axes FROM lsadmin;
GRANT ALL ON TABLE axes TO lsadmin;
GRANT SELECT ON TABLE axes TO PUBLIC;


--
-- Name: datasets_dskey_seq; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON SEQUENCE datasets_dskey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE datasets_dskey_seq FROM lsadmin;
GRANT SELECT,UPDATE ON SEQUENCE datasets_dskey_seq TO lsadmin;
GRANT SELECT,UPDATE ON SEQUENCE datasets_dskey_seq TO PUBLIC;


--
-- Name: dsstates; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE dsstates FROM PUBLIC;
REVOKE ALL ON TABLE dsstates FROM lsadmin;
GRANT ALL ON TABLE dsstates TO lsadmin;
GRANT SELECT ON TABLE dsstates TO PUBLIC;


--
-- Name: oscsenses; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE oscsenses FROM PUBLIC;
REVOKE ALL ON TABLE oscsenses FROM lsadmin;
GRANT ALL ON TABLE oscsenses TO lsadmin;
GRANT SELECT ON TABLE oscsenses TO PUBLIC;


--
-- Name: shots_skey_seq; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON SEQUENCE shots_skey_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE shots_skey_seq FROM lsadmin;
GRANT SELECT,UPDATE ON SEQUENCE shots_skey_seq TO lsadmin;
GRANT SELECT,UPDATE ON SEQUENCE shots_skey_seq TO PUBLIC;


--
-- Name: shotstates; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE shotstates FROM PUBLIC;
REVOKE ALL ON TABLE shotstates FROM lsadmin;
GRANT ALL ON TABLE shotstates TO lsadmin;
GRANT SELECT ON TABLE shotstates TO PUBLIC;


--
-- Name: stations; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE stations FROM PUBLIC;
REVOKE ALL ON TABLE stations FROM lsadmin;
GRANT ALL ON TABLE stations TO lsadmin;
GRANT SELECT ON TABLE stations TO PUBLIC;


--
-- Name: stypes; Type: ACL; Schema: px; Owner: lsadmin
--

REVOKE ALL ON TABLE stypes FROM PUBLIC;
REVOKE ALL ON TABLE stypes FROM lsadmin;
GRANT ALL ON TABLE stypes TO lsadmin;
GRANT SELECT ON TABLE stypes TO PUBLIC;


--
-- PostgreSQL database dump complete
--

